package hash

import (
	"encoding/hex"
	"log"
	"testing"
)

// helper: parse hex into [32]byte
func must32(h string) [32]byte {
	b, err := hex.DecodeString(h)
	if err != nil || len(b) != 32 {
		log.Fatalf("bad hex: %v", err)
	}
	var a [32]byte
	copy(a[:], b)
	return a
}

func TestMerkleRootWithSpecificTxids(t *testing.T) {
	// These are *internal* byte-order tx hashes (32 bytes each).
	// If you paste txids from a block explorer (big-endian display),
	// reverse byte order first using hash.Reverse32.
	tx1 := must32("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
	tx2 := must32("bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb")
	tx3 := must32("cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc")
	tx4 := must32("dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd")

	leaves := [][32]byte{tx1, tx2, tx3, tx4}
	root := MerkleRoot(leaves)

	// Print the result for verification
	t.Logf("Merkle Root (hex): %x", root)

	// Verify the root is 32 bytes
	if len(root) != 32 {
		t.Errorf("Expected root to be 32 bytes, got %d", len(root))
	}

	// Verify the root is not all zeros (basic sanity check)
	allZeros := true
	for _, b := range root {
		if b != 0 {
			allZeros = false
			break
		}
	}
	if allZeros {
		t.Error("Root should not be all zeros")
	}
}

func TestMerkleRoot(t *testing.T) {
	tests := []struct {
		name     string
		leaves   [][32]byte
		expected [32]byte
	}{
		{
			name:     "empty tree",
			leaves:   [][32]byte{},
			expected: [32]byte{}, // Zero hash
		},
		{
			name: "single leaf",
			leaves: [][32]byte{
				{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
					0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20},
			},
			expected: [32]byte{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
				0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20},
		},
		{
			name: "two leaves",
			leaves: [][32]byte{
				{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
					0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20},
				{0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,
					0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40},
			},
			expected: [32]byte{}, // Will be calculated by SHA256D
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := MerkleRoot(tt.leaves)

			// Verify the result is 32 bytes
			if len(result) != 32 {
				t.Errorf("MerkleRoot() returned hash of length %d, expected 32", len(result))
			}

			// For non-empty expected values, check they match
			if tt.expected != [32]byte{} {
				if result != tt.expected {
					t.Errorf("MerkleRoot() = %x, expected %x", result, tt.expected)
				}
			}
		})
	}
}

func TestVerifyMerkleProof(t *testing.T) {
	tests := []struct {
		name      string
		leaf      [32]byte
		steps     []MerkleProofStep
		wantRoot  [32]byte
		expected  bool
		expectErr bool
	}{
		{
			name: "single leaf tree - valid",
			leaf: [32]byte{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
				0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20},
			steps: []MerkleProofStep{},
			wantRoot: [32]byte{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
				0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20},
			expected:  true,
			expectErr: false,
		},
		{
			name: "single leaf tree - invalid",
			leaf: [32]byte{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
				0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20},
			steps: []MerkleProofStep{},
			wantRoot: [32]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
				0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
			expected:  false,
			expectErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := VerifyMerkleProof(tt.leaf, tt.steps, tt.wantRoot)

			if tt.expectErr && err == nil {
				t.Error("VerifyMerkleProof() expected error but got none")
			}
			if !tt.expectErr && err != nil {
				t.Errorf("VerifyMerkleProof() unexpected error: %v", err)
			}

			if result != tt.expected {
				t.Errorf("VerifyMerkleProof() = %t, expected %t", result, tt.expected)
			}
		})
	}
}

func TestReverse32(t *testing.T) {
	tests := []struct {
		name     string
		input    [32]byte
		expected [32]byte
	}{
		{
			name: "simple reversal",
			input: [32]byte{
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
				0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
			},
			expected: [32]byte{
				0x20, 0x1F, 0x1E, 0x1D, 0x1C, 0x1B, 0x1A, 0x19, 0x18, 0x17, 0x16, 0x15, 0x14, 0x13, 0x12, 0x11,
				0x10, 0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01,
			},
		},
		{
			name: "all zeros",
			input: [32]byte{
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
			expected: [32]byte{
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := Reverse32(tt.input)

			if result != tt.expected {
				t.Errorf("Reverse32() = %x, expected %x", result, tt.expected)
			}
		})
	}
}
